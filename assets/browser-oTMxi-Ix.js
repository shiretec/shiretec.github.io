var ht=Object.defineProperty;var ft=(e,t,r)=>t in e?ht(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var E=(e,t,r)=>(ft(e,typeof t!="symbol"?t+"":t,r),r),de=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)};var N=(e,t,r)=>(de(e,t,"read from private field"),r?r.call(e):t.get(e)),he=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},Me=(e,t,r,s)=>(de(e,t,"write to private field"),s?s.call(e,r):t.set(e,r),r);var Y=(e,t,r)=>(de(e,t,"access private method"),r);import{D as pt,i as W,I as gt,c as mt,k as yt,o as vt,t as Le,d as p,g as M,S as bt,h as Xe,R as wt,a as Et,b as f,e as g,H as u,p as L}from"./db-SziduQj-.js";import{Z as m}from"./index-Ho_YSQMq.js";function kt(e){return{status:e.status,statusText:e.statusText,headers:Object.fromEntries(e.headers.entries())}}function qe(e){return t=>t!=null&&typeof t=="object"&&"__kind"in t&&t.__kind===e}function _e(e){return e!=null&&typeof e=="object"&&!Array.isArray(e)}function ze(e,t){return Object.entries(t).reduce((r,[s,n])=>{const o=r[s];return Array.isArray(o)&&Array.isArray(n)?(r[s]=o.concat(n),r):_e(o)&&_e(n)?(r[s]=ze(o,n),r):(r[s]=n,r)},Object.assign({},e))}function St(e){const t=Object.getOwnPropertyDescriptor(globalThis,e);return typeof t>"u"||typeof t.get=="function"&&typeof t.get()>"u"||typeof t.get>"u"&&t.value==null?!1:typeof t.set>"u"&&!t.configurable?(console.error(`[MSW] Failed to apply interceptor: the global \`${e}\` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.`),!1):!0}function v(e,t){return Object.defineProperties(t,{target:{value:e,enumerable:!0,writable:!0},currentTarget:{value:e,enumerable:!0,writable:!0}}),t}var D=Symbol("kCancelable"),R=Symbol("kDefaultPrevented"),Ie=class extends MessageEvent{constructor(e,t){super(e,t),this[D]=!!t.cancelable,this[R]=!1}get cancelable(){return this[D]}set cancelable(e){this[D]=e}get defaultPrevented(){return this[R]}set defaultPrevented(e){this[R]=e}preventDefault(){this.cancelable&&!this[R]&&(this[R]=!0)}},ae=class extends Event{constructor(e,t={}){super(e,t),this.code=t.code===void 0?0:t.code,this.reason=t.reason===void 0?"":t.reason,this.wasClean=t.wasClean===void 0?!1:t.wasClean}},je=class extends ae{constructor(e,t={}){super(e,t),this[D]=!!t.cancelable,this[R]=!1}get cancelable(){return this[D]}set cancelable(e){this[D]=e}get defaultPrevented(){return this[R]}set defaultPrevented(e){this[R]=e}preventDefault(){this.cancelable&&!this[R]&&(this[R]=!0)}},F=Symbol("kEmitter"),Q=Symbol("kBoundListener"),Rt=class{constructor(e,t){this.socket=e,this.transport=t,this.id=mt(),this.url=new URL(e.url),this[F]=new EventTarget,this.transport.addEventListener("outgoing",r=>{const s=v(this.socket,new Ie("message",{data:r.data,origin:r.origin,cancelable:!0}));this[F].dispatchEvent(s),s.defaultPrevented&&r.preventDefault()}),this.transport.addEventListener("close",r=>{this[F].dispatchEvent(v(this.socket,new ae("close",r)))})}addEventListener(e,t,r){if(!Reflect.has(t,Q)){const s=t.bind(this.socket);Object.defineProperty(t,Q,{value:s,enumerable:!1,configurable:!1})}this[F].addEventListener(e,Reflect.get(t,Q),r)}removeEventListener(e,t,r){this[F].removeEventListener(e,Reflect.get(t,Q),r)}send(e){this.transport.send(e)}close(e,t){this.transport.close(e,t)}},Ae="InvalidAccessError: close code out of user configurable range",ne=Symbol("kPassthroughPromise"),Ke=Symbol("kOnSend"),K=Symbol("kClose"),V=class extends EventTarget{constructor(e,t){super(),this.CONNECTING=0,this.OPEN=1,this.CLOSING=2,this.CLOSED=3,this._onopen=null,this._onmessage=null,this._onerror=null,this._onclose=null,this.url=e.toString(),this.protocol="",this.extensions="",this.binaryType="blob",this.readyState=this.CONNECTING,this.bufferedAmount=0,this[ne]=new pt,queueMicrotask(async()=>{await this[ne]||(this.protocol=typeof t=="string"?t:Array.isArray(t)&&t.length>0?t[0]:"",this.readyState===this.CONNECTING&&(this.readyState=this.OPEN,this.dispatchEvent(v(this,new Event("open")))))})}set onopen(e){this.removeEventListener("open",this._onopen),this._onopen=e,e!==null&&this.addEventListener("open",e)}get onopen(){return this._onopen}set onmessage(e){this.removeEventListener("message",this._onmessage),this._onmessage=e,e!==null&&this.addEventListener("message",e)}get onmessage(){return this._onmessage}set onerror(e){this.removeEventListener("error",this._onerror),this._onerror=e,e!==null&&this.addEventListener("error",e)}get onerror(){return this._onerror}set onclose(e){this.removeEventListener("close",this._onclose),this._onclose=e,e!==null&&this.addEventListener("close",e)}get onclose(){return this._onclose}send(e){if(this.readyState===this.CONNECTING)throw this.close(),new DOMException("InvalidStateError");this.readyState===this.CLOSING||this.readyState===this.CLOSED||(this.bufferedAmount+=Lt(e),queueMicrotask(()=>{var t;this.bufferedAmount=0,(t=this[Ke])==null||t.call(this,e)}))}close(e=1e3,t){W(e,Ae),W(e===1e3||e>=3e3&&e<=4999,Ae),this[K](e,t)}[K](e=1e3,t,r=!0){this.readyState===this.CLOSING||this.readyState===this.CLOSED||(this.readyState=this.CLOSING,queueMicrotask(()=>{this.readyState=this.CLOSED,this.dispatchEvent(v(this,new ae("close",{code:e,reason:t,wasClean:r}))),this._onopen=null,this._onmessage=null,this._onerror=null,this._onclose=null}))}addEventListener(e,t,r){return super.addEventListener(e,t,r)}removeEventListener(e,t,r){return super.removeEventListener(e,t,r)}};V.CONNECTING=0;V.OPEN=1;V.CLOSING=2;V.CLOSED=3;function Lt(e){return typeof e=="string"?e.length:e instanceof Blob?e.size:e.byteLength}var I=Symbol("kEmitter"),Z=Symbol("kBoundListener"),fe=Symbol("kSend"),qt=class{constructor(e,t,r){this.client=e,this.transport=t,this.createConnection=r,this[I]=new EventTarget,this.mockCloseController=new AbortController,this.realCloseController=new AbortController,this.transport.addEventListener("outgoing",s=>{typeof this.realWebSocket>"u"||queueMicrotask(()=>{s.defaultPrevented||this[fe](s.data)})}),this.transport.addEventListener("incoming",this.handleIncomingMessage.bind(this))}get socket(){return W(this.realWebSocket,'Cannot access "socket" on the original WebSocket server object: the connection is not open. Did you forget to call `server.connect()`?'),this.realWebSocket}connect(){W(!this.realWebSocket||this.realWebSocket.readyState!==WebSocket.OPEN,'Failed to call "connect()" on the original WebSocket instance: the connection already open');const e=this.createConnection();e.binaryType=this.client.binaryType,e.addEventListener("open",t=>{this[I].dispatchEvent(v(this.realWebSocket,new Event("open",t)))},{once:!0}),e.addEventListener("message",t=>{this.transport.dispatchEvent(v(this.realWebSocket,new MessageEvent("incoming",{data:t.data,origin:t.origin})))}),this.client.addEventListener("close",t=>{this.handleMockClose(t)},{signal:this.mockCloseController.signal}),e.addEventListener("close",t=>{this.handleRealClose(t)},{signal:this.realCloseController.signal}),e.addEventListener("error",()=>{const t=v(e,new Event("error",{cancelable:!0}));this[I].dispatchEvent(t),t.defaultPrevented||this.client.dispatchEvent(v(this.client,new Event("error")))}),this.realWebSocket=e}addEventListener(e,t,r){if(!Reflect.has(t,Z)){const s=t.bind(this.client);Object.defineProperty(t,Z,{value:s,enumerable:!1})}this[I].addEventListener(e,Reflect.get(t,Z),r)}removeEventListener(e,t,r){this[I].removeEventListener(e,Reflect.get(t,Z),r)}send(e){this[fe](e)}[fe](e){const{realWebSocket:t}=this;if(W(t,'Failed to call "server.send()" for "%s": the connection is not open. Did you forget to call "server.connect()"?',this.client.url),!(t.readyState===WebSocket.CLOSING||t.readyState===WebSocket.CLOSED)){if(t.readyState===WebSocket.CONNECTING){t.addEventListener("open",()=>{t.send(e)},{once:!0});return}t.send(e)}}close(){const{realWebSocket:e}=this;W(e,'Failed to close server connection for "%s": the connection is not open. Did you forget to call "server.connect()"?',this.client.url),this.realCloseController.abort(),!(e.readyState===WebSocket.CLOSING||e.readyState===WebSocket.CLOSED)&&(e.close(),queueMicrotask(()=>{this[I].dispatchEvent(v(this.realWebSocket,new je("close",{code:1e3,cancelable:!0})))}))}handleIncomingMessage(e){const t=v(e.target,new Ie("message",{data:e.data,origin:e.origin,cancelable:!0}));this[I].dispatchEvent(t),t.defaultPrevented||this.client.dispatchEvent(v(this.client,new MessageEvent("message",{data:e.data,origin:e.origin})))}handleMockClose(e){this.realWebSocket&&this.realWebSocket.close()}handleRealClose(e){this.mockCloseController.abort();const t=v(this.realWebSocket,new je("close",{code:e.code,reason:e.reason,wasClean:e.wasClean,cancelable:!0}));this[I].dispatchEvent(t),t.defaultPrevented||this.client[K](e.code,e.reason)}},It=class extends EventTarget{constructor(e){super(),this.socket=e,this.socket.addEventListener("close",t=>{this.dispatchEvent(v(this.socket,new ae("close",t)))}),this.socket[Ke]=t=>{this.dispatchEvent(v(this.socket,new Ie("outgoing",{data:t,origin:this.socket.url,cancelable:!0})))}}addEventListener(e,t,r){return super.addEventListener(e,t,r)}dispatchEvent(e){return super.dispatchEvent(e)}send(e){queueMicrotask(()=>{if(this.socket.readyState===this.socket.CLOSING||this.socket.readyState===this.socket.CLOSED)return;const t=()=>{this.socket.dispatchEvent(v(this.socket,new MessageEvent("message",{data:e,origin:this.socket.url})))};this.socket.readyState===this.socket.CONNECTING?this.socket.addEventListener("open",()=>{t()},{once:!0}):t()})}close(e,t){this.socket[K](e,t)}},Ve=class extends gt{constructor(){super(Ve.symbol)}checkEnvironment(){return St("WebSocket")}setup(){const e=Object.getOwnPropertyDescriptor(globalThis,"WebSocket"),t=new Proxy(globalThis.WebSocket,{construct:(r,s,n)=>{const[o,i]=s,a=()=>Reflect.construct(r,s,n),c=new V(o,i),l=new It(c);return queueMicrotask(()=>{try{const d=new qt(c,l,a);this.emitter.emit("connection",{client:new Rt(c,l),server:d,info:{protocols:i}})?c[ne].resolve(!1):(c[ne].resolve(!0),d.connect(),d.addEventListener("open",()=>{c.dispatchEvent(v(c,new Event("open"))),d.realWebSocket&&(c.protocol=d.realWebSocket.protocol)}))}catch(d){d instanceof Error&&(c.dispatchEvent(new Event("error")),c.readyState!==WebSocket.CLOSING&&c.readyState!==WebSocket.CLOSED&&c[K](1011,d.message,!1),console.error(d))}}),c}});Object.defineProperty(globalThis,"WebSocket",{value:t,configurable:!0}),this.subscriptions.push(()=>{Object.defineProperty(globalThis,"WebSocket",e)})}},Je=Ve;Je.symbol=Symbol("websocket");const be=new Je;function Ct(e){be.on("connection",async t=>{const r=e.getHandlers(),s=new MessageEvent("connection",{data:t}),n=[];for(const o of r)qe("EventHandler")(o)&&o.predicate({event:s,parsedResult:o.parse({event:s})})&&n.push(o);if(n.length>0){e==null||e.onMockedConnection(t);for(const o of n)o[yt](s)}else{const o=new Request(t.client.url,{headers:{upgrade:"websocket",connection:"upgrade"}});await vt(o,e.getUnhandledRequestStrategy()).catch(i=>{const a=new Event("error");Object.defineProperty(a,"cause",{enumerable:!0,configurable:!1,value:i}),t.client.socket.dispatchEvent(a)}),e==null||e.onPassthroughConnection(t),t.server.connect()}})}function ce(e){return e instanceof Blob?e.size:e instanceof ArrayBuffer?e.byteLength:new Blob([e]).size}const We=24;function pe(e){return e.length<=We?e:`${e.slice(0,We)}…`}async function le(e){if(e instanceof Blob){const t=await e.text();return`Blob(${pe(t)})`}if(typeof e=="object"&&"byteLength"in e){const t=new TextDecoder().decode(e);return`ArrayBuffer(${pe(t)})`}return pe(e)}const _={system:"#3b82f6",outgoing:"#22c55e",incoming:"#ef4444",mocked:"#ff6a33"};function Tt(e){const{client:t,server:r}=e;Pt(t),t.addEventListener("message",s=>{Mt(s)}),t.addEventListener("close",s=>{Ot(s)}),t.socket.addEventListener("error",s=>{xt(s)}),t.send=new Proxy(t.send,{apply(s,n,o){const[i]=o,a=new MessageEvent("message",{data:i});return Object.defineProperties(a,{currentTarget:{enumerable:!0,writable:!1,value:t.socket},target:{enumerable:!0,writable:!1,value:t.socket}}),queueMicrotask(()=>{jt(a)}),Reflect.apply(s,n,o)}}),r.addEventListener("open",()=>{r.addEventListener("message",s=>{At(s)})},{once:!0}),r.send=new Proxy(r.send,{apply(s,n,o){const[i]=o,a=new MessageEvent("message",{data:i});return Object.defineProperties(a,{currentTarget:{enumerable:!0,writable:!1,value:r.socket},target:{enumerable:!0,writable:!1,value:r.socket}}),_t(a),Reflect.apply(s,n,o)}})}function Pt(e){const t=Le(e.url);console.groupCollapsed(p.formatMessage(`${M()} %c▶%c ${t}`),`color:${_.system}`,"color:inherit"),console.log("Client:",e.socket),console.groupEnd()}function Ot(e){const t=e.target,r=Le(t.url);console.groupCollapsed(p.formatMessage(`${M({milliseconds:!0})} %c■%c ${r}`),`color:${_.system}`,"color:inherit"),console.log(e),console.groupEnd()}function xt(e){const t=e.target,r=Le(t.url);console.groupCollapsed(p.formatMessage(`${M({milliseconds:!0})} %c×%c ${r}`),`color:${_.system}`,"color:inherit"),console.log(e),console.groupEnd()}async function Mt(e){const t=ce(e.data),r=await le(e.data),s=e.defaultPrevented?"⇡":"⬆";console.groupCollapsed(p.formatMessage(`${M({milliseconds:!0})} %c${s}%c ${r} %c${t}%c`),`color:${_.outgoing}`,"color:inherit","color:gray;font-weight:normal","color:inherit;font-weight:inherit"),console.log(e),console.groupEnd()}async function _t(e){const t=ce(e.data),r=await le(e.data);console.groupCollapsed(p.formatMessage(`${M({milliseconds:!0})} %c⬆%c ${r} %c${t}%c`),`color:${_.mocked}`,"color:inherit","color:gray;font-weight:normal","color:inherit;font-weight:inherit"),console.log(e),console.groupEnd()}async function jt(e){const t=ce(e.data),r=await le(e.data);console.groupCollapsed(p.formatMessage(`${M({milliseconds:!0})} %c⬇%c ${r} %c${t}%c`),`color:${_.mocked}`,"color:inherit","color:gray;font-weight:normal","color:inherit;font-weight:inherit"),console.log(e),console.groupEnd()}async function At(e){const t=ce(e.data),r=await le(e.data),s=e.defaultPrevented?"⇣":"⬇";console.groupCollapsed(p.formatMessage(`${M({milliseconds:!0})} %c${s}%c ${r} %c${t}%c`),`color:${_.incoming}`,"color:inherit","color:gray;font-weight:normal","color:inherit;font-weight:inherit"),console.log(e),console.groupEnd()}var Wt={},Dt=/(%?)(%([sdijo]))/g;function Ut(e,t){switch(t){case"s":return e;case"d":case"i":return Number(e);case"j":return JSON.stringify(e);case"o":{if(typeof e=="string")return e;const r=JSON.stringify(e);return r==="{}"||r==="[]"||/^\[object .+?\]$/.test(r)?e:r}}}function J(e,...t){if(t.length===0)return e;let r=0,s=e.replace(Dt,(n,o,i,a)=>{const c=t[r],l=Ut(c,a);return o?n:(r++,l)});return r<t.length&&(s+=` ${t.slice(r).join(" ")}`),s=s.replace(/%{2,2}/g,"%"),s}var Ht=2;function $t(e){if(!e.stack)return;const t=e.stack.split(`
`);t.splice(1,Ht),e.stack=t.join(`
`)}var Bt=class extends Error{constructor(e,...t){super(e),this.message=e,this.name="Invariant Violation",this.message=J(e,...t),$t(this)}},P=(e,t,...r)=>{if(!e)throw new Bt(t,...r)};P.as=(e,t,r,...s)=>{if(!t){const n=s.length===0?r:J(r,...s);let o;try{o=Reflect.construct(e,[n])}catch{o=e(n)}throw o}};function Ce(){if(typeof navigator<"u"&&navigator.product==="ReactNative")return!0;if(typeof process<"u"){const e=process.type;return e==="renderer"||e==="worker"?!1:!!(process.versions&&process.versions.node)}return!1}var we=async e=>{try{return{error:null,data:await e().catch(r=>{throw r})}}catch(t){return{error:t,data:null}}};function Nt(e){return new URL(e,location.href).href}function ge(e,t,r){return[e.active,e.installing,e.waiting].filter(i=>i!=null).find(i=>r(i.scriptURL,t))||null}var Ft=async(e,t={},r)=>{const s=Nt(e),n=await navigator.serviceWorker.getRegistrations().then(a=>a.filter(c=>ge(c,s,r)));!navigator.serviceWorker.controller&&n.length>0&&location.reload();const[o]=n;if(o)return o.update(),[ge(o,s,r),o];const i=await we(async()=>{const a=await navigator.serviceWorker.register(e,t);return[ge(a,s,r),a]});if(i.error){if(i.error.message.includes("(404)")){const c=new URL((t==null?void 0:t.scope)||"/",location.href);throw new Error(p.formatMessage(`Failed to register a Service Worker for scope ('${c.href}') with script ('${s}'): Service Worker script does not exist at the given path.

Did you forget to run "npx msw init <PUBLIC_DIR>"?

Learn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`))}throw new Error(p.formatMessage(`Failed to register the Service Worker:

%s`,i.error.message))}return i.data};function Ye(e={}){if(e.quiet)return;const t=e.message||"Mocking enabled.";console.groupCollapsed(`%c${p.formatMessage(t)}`,"color:orangered;font-weight:bold;"),console.log("%cDocumentation: %chttps://mswjs.io/docs","font-weight:bold","font-weight:normal"),console.log("Found an issue? https://github.com/mswjs/msw/issues"),e.workerUrl&&console.log("Worker script URL:",e.workerUrl),e.workerScope&&console.log("Worker scope:",e.workerScope),e.client&&console.log("Client ID: %s (%s)",e.client.id,e.client.frameType),console.groupEnd()}async function Gt(e,t){var s,n;e.workerChannel.send("MOCK_ACTIVATE");const{payload:r}=await e.events.once("MOCKING_ENABLED");if(e.isMockingEnabled){p.warn('Found a redundant "worker.start()" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this "worker.start()" call.');return}e.isMockingEnabled=!0,Ye({quiet:t.quiet,workerScope:(s=e.registration)==null?void 0:s.scope,workerUrl:(n=e.worker)==null?void 0:n.scriptURL,client:r.client})}var Xt=class{constructor(e){this.port=e}postMessage(e,...t){const[r,s]=t;this.port.postMessage({type:e,data:r},{transfer:s})}};function zt(e){if(!["HEAD","GET"].includes(e.method))return e.body}function Kt(e){return new Request(e.url,{...e,body:zt(e)})}var Vt=(e,t)=>async(r,s)=>{const n=new Xt(r.ports[0]),o=s.payload.id,i=Kt(s.payload),a=i.clone(),c=i.clone();wt.cache.set(i,c),e.requests.set(o,c);try{await Xe(i,o,e.getRequestHandlers().filter(qe("RequestHandler")),t,e.emitter,{onPassthroughResponse(){n.postMessage("PASSTHROUGH")},async onMockedResponse(l,{handler:d,parsedResult:h}){const w=l.clone(),O=l.clone(),xe=kt(l);if(e.supports.readableStreamTransfer){const B=l.body;n.postMessage("MOCK_RESPONSE",{...xe,body:B},B?[B]:void 0)}else{const B=l.body===null?null:await w.arrayBuffer();n.postMessage("MOCK_RESPONSE",{...xe,body:B})}t.quiet||e.emitter.once("response:mocked",()=>{d.log({request:a,response:O,parsedResult:h})})}})}catch(l){l instanceof Error&&(p.error(`Uncaught exception in the request handler for "%s %s":

%s

This exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,i.method,i.url,l.stack??l),n.postMessage("MOCK_RESPONSE",{status:500,statusText:"Request Handler Error",headers:{"Content-Type":"application/json"},body:JSON.stringify({name:l.name,message:l.message,stack:l.stack})}))}};async function Jt(e){e.workerChannel.send("INTEGRITY_CHECK_REQUEST");const{payload:t}=await e.events.once("INTEGRITY_CHECK_RESPONSE");t.checksum!=="00729d72e3b82faf54ca8b9621dbb96f"&&p.warn(`The currently registered Service Worker has been generated by a different version of MSW (${t.packageVersion}) and may not be fully compatible with the installed version.

It's recommended you update your worker script by running this command:

  • npx msw init <PUBLIC_DIR>

You can also automate this process and make the worker script update automatically upon the library installations. Read more: https://mswjs.io/docs/cli/init.`)}var Yt=new TextEncoder;function Qt(e){return Yt.encode(e)}function Zt(e,t){return new TextDecoder(t).decode(e)}function er(e){return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}var U=Symbol("isPatchedModule"),A=class extends Response{static isConfigurableStatusCode(e){return e>=200&&e<=599}static isRedirectResponse(e){return A.STATUS_CODES_WITH_REDIRECT.includes(e)}static isResponseWithBody(e){return!A.STATUS_CODES_WITHOUT_BODY.includes(e)}static setUrl(e,t){e&&t.url==""&&Object.defineProperty(t,"url",{value:e,enumerable:!0,configurable:!0,writable:!1})}constructor(e,t={}){var r;const s=(r=t.status)!=null?r:200,n=A.isConfigurableStatusCode(s)?s:200,o=A.isResponseWithBody(s)?e:null;if(super(o,{...t,status:n}),s!==n){const i=Object.getOwnPropertySymbols(this).find(a=>a.description==="state");if(i){const a=Reflect.get(this,i);Reflect.set(a,"status",s)}else Object.defineProperty(this,"status",{value:s,enumerable:!0,configurable:!0,writable:!1})}A.setUrl(t.url,this)}},q=A;q.STATUS_CODES_WITHOUT_BODY=[101,103,204,205,304];q.STATUS_CODES_WITH_REDIRECT=[301,302,303,307,308];var tr=Object.defineProperty,rr=(e,t)=>{for(var r in t)tr(e,r,{get:t[r],enumerable:!0})},Ee={};rr(Ee,{blue:()=>nr,gray:()=>ke,green:()=>ir,red:()=>or,yellow:()=>sr});function sr(e){return`\x1B[33m${e}\x1B[0m`}function nr(e){return`\x1B[34m${e}\x1B[0m`}function ke(e){return`\x1B[90m${e}\x1B[0m`}function or(e){return`\x1B[31m${e}\x1B[0m`}function ir(e){return`\x1B[32m${e}\x1B[0m`}var ue=Ce(),Qe=class{constructor(e){E(this,"prefix");this.name=e,this.prefix=`[${this.name}]`;const t=De("DEBUG"),r=De("LOG_LEVEL");t==="1"||t==="true"||typeof t<"u"&&this.name.startsWith(t)?(this.debug=G(r,"debug")?k:this.debug,this.info=G(r,"info")?k:this.info,this.success=G(r,"success")?k:this.success,this.warning=G(r,"warning")?k:this.warning,this.error=G(r,"error")?k:this.error):(this.info=k,this.success=k,this.warning=k,this.error=k,this.only=k)}extend(e){return new Qe(`${this.name}:${e}`)}debug(e,...t){this.logEntry({level:"debug",message:ke(e),positionals:t,prefix:this.prefix,colors:{prefix:"gray"}})}info(e,...t){this.logEntry({level:"info",message:e,positionals:t,prefix:this.prefix,colors:{prefix:"blue"}});const r=new ar;return(s,...n)=>{r.measure(),this.logEntry({level:"info",message:`${s} ${ke(`${r.deltaTime}ms`)}`,positionals:n,prefix:this.prefix,colors:{prefix:"blue"}})}}success(e,...t){this.logEntry({level:"info",message:e,positionals:t,prefix:`✔ ${this.prefix}`,colors:{timestamp:"green",prefix:"green"}})}warning(e,...t){this.logEntry({level:"warning",message:e,positionals:t,prefix:`⚠ ${this.prefix}`,colors:{timestamp:"yellow",prefix:"yellow"}})}error(e,...t){this.logEntry({level:"error",message:e,positionals:t,prefix:`✖ ${this.prefix}`,colors:{timestamp:"red",prefix:"red"}})}only(e){e()}createEntry(e,t){return{timestamp:new Date,level:e,message:t}}logEntry(e){const{level:t,message:r,prefix:s,colors:n,positionals:o=[]}=e,i=this.createEntry(t,r),a=(n==null?void 0:n.timestamp)||"gray",c=(n==null?void 0:n.prefix)||"gray",l={timestamp:Ee[a],prefix:Ee[c]};this.getWriter(t)([l.timestamp(this.formatTimestamp(i.timestamp))].concat(s!=null?l.prefix(s):[]).concat(Ue(r)).join(" "),...o.map(Ue))}formatTimestamp(e){return`${e.toLocaleTimeString("en-GB")}:${e.getMilliseconds()}`}getWriter(e){switch(e){case"debug":case"success":case"info":return cr;case"warning":return lr;case"error":return ur}}},ar=class{constructor(){E(this,"startTime");E(this,"endTime");E(this,"deltaTime");this.startTime=performance.now()}measure(){this.endTime=performance.now();const e=this.endTime-this.startTime;this.deltaTime=e.toFixed(2)}},k=()=>{};function cr(e,...t){if(ue){process.stdout.write(J(e,...t)+`
`);return}console.log(e,...t)}function lr(e,...t){if(ue){process.stderr.write(J(e,...t)+`
`);return}console.warn(e,...t)}function ur(e,...t){if(ue){process.stderr.write(J(e,...t)+`
`);return}console.error(e,...t)}function De(e){var t;return ue?Wt[e]:(t=globalThis[e])==null?void 0:t.toString()}function G(e,t){return e!==void 0&&e!==t}function Ue(e){return typeof e>"u"?"undefined":e===null?"null":typeof e=="string"?e:typeof e=="object"?JSON.stringify(e):e.toString()}var dr=class extends Error{constructor(e,t,r){super(`Possible EventEmitter memory leak detected. ${r} ${t.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`),this.emitter=e,this.type=t,this.count=r,this.name="MaxListenersExceededWarning"}},Ze=class{static listenerCount(e,t){return e.listenerCount(t)}constructor(){this.events=new Map,this.maxListeners=Ze.defaultMaxListeners,this.hasWarnedAboutPotentialMemoryLeak=!1}_emitInternalEvent(e,t,r){this.emit(e,t,r)}_getListeners(e){return Array.prototype.concat.apply([],this.events.get(e))||[]}_removeListener(e,t){const r=e.indexOf(t);return r>-1&&e.splice(r,1),[]}_wrapOnceListener(e,t){const r=(...s)=>(this.removeListener(e,r),t.apply(this,s));return Object.defineProperty(r,"name",{value:t.name}),r}setMaxListeners(e){return this.maxListeners=e,this}getMaxListeners(){return this.maxListeners}eventNames(){return Array.from(this.events.keys())}emit(e,...t){const r=this._getListeners(e);return r.forEach(s=>{s.apply(this,t)}),r.length>0}addListener(e,t){this._emitInternalEvent("newListener",e,t);const r=this._getListeners(e).concat(t);if(this.events.set(e,r),this.maxListeners>0&&this.listenerCount(e)>this.maxListeners&&!this.hasWarnedAboutPotentialMemoryLeak){this.hasWarnedAboutPotentialMemoryLeak=!0;const s=new dr(this,e,this.listenerCount(e));console.warn(s)}return this}on(e,t){return this.addListener(e,t)}once(e,t){return this.addListener(e,this._wrapOnceListener(e,t))}prependListener(e,t){const r=this._getListeners(e);if(r.length>0){const s=[t].concat(r);this.events.set(e,s)}else this.events.set(e,r.concat(t));return this}prependOnceListener(e,t){return this.prependListener(e,this._wrapOnceListener(e,t))}removeListener(e,t){const r=this._getListeners(e);return r.length>0&&(this._removeListener(r,t),this.events.set(e,r),this._emitInternalEvent("removeListener",e,t)),this}off(e,t){return this.removeListener(e,t)}removeAllListeners(e){return e?this.events.delete(e):this.events.clear(),this}listeners(e){return Array.from(this._getListeners(e))}listenerCount(e){return this._getListeners(e).length}rawListeners(e){return this.listeners(e)}},et=Ze;et.defaultMaxListeners=10;var hr="x-interceptors-internal-request-id";function He(e){return globalThis[e]||void 0}function fr(e,t){globalThis[e]=t}function pr(e){delete globalThis[e]}var Te=class{constructor(e){this.symbol=e,this.readyState="INACTIVE",this.emitter=new et,this.subscriptions=[],this.logger=new Qe(e.description),this.emitter.setMaxListeners(0),this.logger.info("constructing the interceptor...")}checkEnvironment(){return!0}apply(){const e=this.logger.extend("apply");if(e.info("applying the interceptor..."),this.readyState==="APPLIED"){e.info("intercepted already applied!");return}if(!this.checkEnvironment()){e.info("the interceptor cannot be applied in this environment!");return}this.readyState="APPLYING";const r=this.getInstance();if(r){e.info("found a running instance, reusing..."),this.on=(s,n)=>(e.info('proxying the "%s" listener',s),r.emitter.addListener(s,n),this.subscriptions.push(()=>{r.emitter.removeListener(s,n),e.info('removed proxied "%s" listener!',s)}),this),this.readyState="APPLIED";return}e.info("no running instance found, setting up a new instance..."),this.setup(),this.setInstance(),this.readyState="APPLIED"}setup(){}on(e,t){const r=this.logger.extend("on");return this.readyState==="DISPOSING"||this.readyState==="DISPOSED"?(r.info("cannot listen to events, already disposed!"),this):(r.info('adding "%s" event listener:',e,t),this.emitter.on(e,t),this)}once(e,t){return this.emitter.once(e,t),this}off(e,t){return this.emitter.off(e,t),this}removeAllListeners(e){return this.emitter.removeAllListeners(e),this}dispose(){const e=this.logger.extend("dispose");if(this.readyState==="DISPOSED"){e.info("cannot dispose, already disposed!");return}if(e.info("disposing the interceptor..."),this.readyState="DISPOSING",!this.getInstance()){e.info("no interceptors running, skipping dispose...");return}if(this.clearInstance(),e.info("global symbol deleted:",He(this.symbol)),this.subscriptions.length>0){e.info("disposing of %d subscriptions...",this.subscriptions.length);for(const t of this.subscriptions)t();this.subscriptions=[],e.info("disposed of all subscriptions!",this.subscriptions.length)}this.emitter.removeAllListeners(),e.info("destroyed the listener!"),this.readyState="DISPOSED"}getInstance(){var e;const t=He(this.symbol);return this.logger.info("retrieved global instance:",(e=t==null?void 0:t.constructor)==null?void 0:e.name),t}setInstance(){fr(this.symbol,this),this.logger.info("set global instance!",this.symbol.description)}clearInstance(){pr(this.symbol),this.logger.info("cleared global instance!",this.symbol.description)}};function tt(){return Math.random().toString(16).slice(2)}var Se=class extends Te{constructor(e){Se.symbol=Symbol(e.name),super(Se.symbol),this.interceptors=e.interceptors}setup(){const e=this.logger.extend("setup");e.info("applying all %d interceptors...",this.interceptors.length);for(const t of this.interceptors)e.info('applying "%s" interceptor...',t.constructor.name),t.apply(),e.info("adding interceptor dispose subscription"),this.subscriptions.push(()=>t.dispose())}on(e,t){for(const r of this.interceptors)r.on(e,t);return this}once(e,t){for(const r of this.interceptors)r.once(e,t);return this}off(e,t){for(const r of this.interceptors)r.off(e,t);return this}removeAllListeners(e){for(const t of this.interceptors)t.removeAllListeners(e);return this}};function gr(e){return(t,r)=>{var a;const{payload:s}=r,{requestId:n}=s,o=e.requests.get(n);if(e.requests.delete(n),(a=s.type)!=null&&a.includes("opaque"))return;const i=s.status===0?Response.error():new q(q.isResponseWithBody(s.status)?s.body:null,{...s,url:o.url});e.emitter.emit(s.isMockedResponse?"response:mocked":"response:bypass",{response:i,request:o,requestId:s.requestId})}}function mr(e,t){!(t!=null&&t.quiet)&&!location.href.startsWith(e.scope)&&p.warn(`Cannot intercept requests on this page because it's outside of the worker's scope ("${e.scope}"). If you wish to mock API requests on this page, you must resolve this scope issue.

- (Recommended) Register the worker at the root level ("/") of your application.
- Set the "Service-Worker-Allowed" response header to allow out-of-scope workers.`)}var yr=e=>function(r,s){return(async()=>{e.events.removeAllListeners(),e.workerChannel.on("REQUEST",Vt(e,r)),e.workerChannel.on("RESPONSE",gr(e));const i=await Ft(r.serviceWorker.url,r.serviceWorker.options,r.findWorker),[a,c]=i;if(!a){const l=s!=null&&s.findWorker?p.formatMessage(`Failed to locate the Service Worker registration using a custom "findWorker" predicate.

Please ensure that the custom predicate properly locates the Service Worker registration at "%s".
More details: https://mswjs.io/docs/api/setup-worker/start#findworker
`,r.serviceWorker.url):p.formatMessage(`Failed to locate the Service Worker registration.

This most likely means that the worker script URL "%s" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.

Please consider using a custom "serviceWorker.url" option to point to the actual worker script location, or a custom "findWorker" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,r.serviceWorker.url,location.host);throw new Error(l)}return e.worker=a,e.registration=c,e.events.addListener(window,"beforeunload",()=>{a.state!=="redundant"&&e.workerChannel.send("CLIENT_CLOSED"),window.clearInterval(e.keepAliveInterval),window.postMessage({type:"msw/worker:stop"})}),await Jt(e).catch(l=>{p.error("Error while checking the worker script integrity. Please report this on GitHub (https://github.com/mswjs/msw/issues), including the original error below."),console.error(l)}),e.keepAliveInterval=window.setInterval(()=>e.workerChannel.send("KEEPALIVE_REQUEST"),5e3),mr(c,e.startOptions),c})().then(async i=>{const a=i.installing||i.waiting;return a&&await new Promise(c=>{a.addEventListener("statechange",()=>{if(a.state==="activated")return c()})}),await Gt(e,r).catch(c=>{throw new Error(`Failed to enable mocking: ${c==null?void 0:c.message}`)}),i})};function rt(e={}){e.quiet||console.log(`%c${p.formatMessage("Mocking disabled.")}`,"color:orangered;font-weight:bold;")}var vr=e=>function(){var r;if(!e.isMockingEnabled){p.warn('Found a redundant "worker.stop()" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this "worker.stop()" call.');return}e.workerChannel.send("MOCK_DEACTIVATE"),e.isMockingEnabled=!1,window.clearInterval(e.keepAliveInterval),window.postMessage({type:"msw/worker:stop"}),rt({quiet:(r=e.startOptions)==null?void 0:r.quiet})},br={serviceWorker:{url:"/mockServiceWorker.js",options:null},quiet:!1,waitUntilReady:!0,onUnhandledRequest:"warn",findWorker(e,t){return e===t}};function wr(){const e=(t,r)=>{e.state="pending",e.resolve=s=>{if(e.state!=="pending")return;e.result=s;const n=o=>(e.state="fulfilled",o);return t(s instanceof Promise?s:Promise.resolve(s).then(n))},e.reject=s=>{if(e.state==="pending")return queueMicrotask(()=>{e.state="rejected"}),r(e.rejectionReason=s)}};return e}var T,H,te,Ge,Pe=(Ge=class extends Promise{constructor(t=null){const r=wr();super((s,n)=>{r(s,n),t==null||t(r.resolve,r.reject)});he(this,H);he(this,T,void 0);E(this,"resolve");E(this,"reject");Me(this,T,r),this.resolve=N(this,T).resolve,this.reject=N(this,T).reject}get state(){return N(this,T).state}get rejectionReason(){return N(this,T).rejectionReason}then(t,r){return Y(this,H,te).call(this,super.then(t,r))}catch(t){return Y(this,H,te).call(this,super.catch(t))}finally(t){return Y(this,H,te).call(this,super.finally(t))}},T=new WeakMap,H=new WeakSet,te=function(t){return Object.defineProperties(t,{resolve:{configurable:!0,value:this.resolve},reject:{configurable:!0,value:this.reject}})},Ge),oe=class extends Error{constructor(e){super(e),this.name="InterceptorError",Object.setPrototypeOf(this,oe.prototype)}},X=Symbol("kRequestHandled"),S=Symbol("kResponsePromise"),Oe=class{constructor(e){this.request=e,this[X]=!1,this[S]=new Pe}respondWith(e){P.as(oe,!this[X],'Failed to respond to the "%s %s" request: the "request" event has already been handled.',this.request.method,this.request.url),this[X]=!0,this[S].resolve(e)}errorWith(e){P.as(oe,!this[X],'Failed to error the "%s %s" request: the "request" event has already been handled.',this.request.method,this.request.url),this[X]=!0,this[S].resolve(e)}};async function ie(e,t,...r){const s=e.listeners(t);if(s.length!==0)for(const n of s)await n.apply(e,r)}function Er(e,t){try{return e[t],!0}catch{return!1}}function kr(e){return new Response(JSON.stringify(e instanceof Error?{name:e.name,message:e.message,stack:e.stack}:e),{status:500,statusText:"Unhandled Exception",headers:{"Content-Type":"application/json"}})}function Sr(e){return Er(e,"type")&&e.type==="error"}function Rr(e){return e==null||!(e instanceof Error)?!1:"code"in e&&"errno"in e}async function st(e){const t=async o=>(o instanceof Error?e.onError(o):Sr(o)?e.onRequestError(o):await e.onResponse(o),!0),r=async o=>{if(o instanceof oe)throw n.error;return Rr(o)?(e.onError(o),!0):o instanceof Response?await t(o):!1};e.emitter.once("request",({requestId:o})=>{o===e.requestId&&e.controller[S].state==="pending"&&e.controller[S].resolve(void 0)});const s=new Pe;e.request.signal&&(e.request.signal.aborted?s.reject(e.request.signal.reason):e.request.signal.addEventListener("abort",()=>{s.reject(e.request.signal.reason)},{once:!0}));const n=await we(async()=>{const o=ie(e.emitter,"request",{requestId:e.requestId,request:e.request,controller:e.controller});return await Promise.race([s,o,e.controller[S]]),await e.controller[S]});if(s.state==="rejected")return e.onError(s.rejectionReason),!0;if(n.error){if(await r(n.error))return!0;if(e.emitter.listenerCount("unhandledException")>0){const o=new Oe(e.request);await ie(e.emitter,"unhandledException",{error:n.error,request:e.request,requestId:e.requestId,controller:o}).then(()=>{o[S].state==="pending"&&o[S].resolve(void 0)});const i=await we(()=>o[S]);if(i.error)return r(i.error);if(i.data)return t(i.data)}return e.onResponse(kr(n.error)),!0}return n.data?t(n.data):!1}function nt(e){const t=Object.getOwnPropertyDescriptor(globalThis,e);return typeof t>"u"||typeof t.get=="function"&&typeof t.get()>"u"||typeof t.get>"u"&&t.value==null?!1:typeof t.set>"u"&&!t.configurable?(console.error(`[MSW] Failed to apply interceptor: the global \`${e}\` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.`),!1):!0}function Lr(e){try{return new URL(e),!0}catch{return!1}}function x(e){return Object.assign(new TypeError("Failed to fetch"),{cause:e})}var qr=["content-encoding","content-language","content-location","content-type","content-length"],me=Symbol("kRedirectCount");async function Ir(e,t){if(t.status!==303&&e.body!=null)return Promise.reject(x());const r=new URL(e.url);let s;try{s=new URL(t.headers.get("location"),e.url)}catch(o){return Promise.reject(x(o))}if(!(s.protocol==="http:"||s.protocol==="https:"))return Promise.reject(x("URL scheme must be a HTTP(S) scheme"));if(Reflect.get(e,me)>20)return Promise.reject(x("redirect count exceeded"));if(Object.defineProperty(e,me,{value:(Reflect.get(e,me)||0)+1}),e.mode==="cors"&&(s.username||s.password)&&!$e(r,s))return Promise.reject(x('cross origin not allowed for request mode "cors"'));const n={};return([301,302].includes(t.status)&&e.method==="POST"||t.status===303&&!["HEAD","GET"].includes(e.method))&&(n.method="GET",n.body=null,qr.forEach(o=>{e.headers.delete(o)})),$e(r,s)||(e.headers.delete("authorization"),e.headers.delete("proxy-authorization"),e.headers.delete("cookie"),e.headers.delete("host")),n.headers=e.headers,fetch(new Request(s,n))}function $e(e,t){return e.origin===t.origin&&e.origin==="null"||e.protocol===t.protocol&&e.hostname===t.hostname&&e.port===t.port}var Cr=class extends TransformStream{constructor(){console.warn("[Interceptors]: Brotli decompression of response streams is not supported in the browser"),super({transform(e,t){t.enqueue(e)}})}},Tr=class extends TransformStream{constructor(e,...t){super({},...t);const r=[super.readable,...e].reduce((s,n)=>s.pipeThrough(n));Object.defineProperty(this,"readable",{get(){return r}})}};function Pr(e){return e.toLowerCase().split(",").map(t=>t.trim())}function Or(e){if(e==="")return null;const t=Pr(e);if(t.length===0)return null;const r=t.reduceRight((s,n)=>n==="gzip"||n==="x-gzip"?s.concat(new DecompressionStream("gzip")):n==="deflate"?s.concat(new DecompressionStream("deflate")):n==="br"?s.concat(new Cr):(s.length=0,s),[]);return new Tr(r)}function xr(e){if(e.body===null)return null;const t=Or(e.headers.get("content-encoding")||"");return t?(e.body.pipeTo(t.writable),t.readable):null}var ot=class extends Te{constructor(){super(ot.symbol)}checkEnvironment(){return nt("fetch")}async setup(){const e=globalThis.fetch;P(!e[U],'Failed to patch the "fetch" module: already patched.'),globalThis.fetch=async(t,r)=>{const s=tt(),n=typeof t=="string"&&typeof location<"u"&&!Lr(t)?new URL(t,location.origin):t,o=new Request(n,r),i=new Pe,a=new Oe(o);return this.logger.info("[%s] %s",o.method,o.url),this.logger.info("awaiting for the mocked response..."),this.logger.info('emitting the "request" event for %s listener(s)...',this.emitter.listenerCount("request")),await st({request:o,requestId:s,emitter:this.emitter,controller:a,onResponse:async l=>{this.logger.info("received mocked response!",{rawResponse:l});const d=xr(l),h=d===null?l:new q(d,l);if(q.setUrl(o.url,h),q.isRedirectResponse(h.status)){if(o.redirect==="error"){i.reject(x("unexpected redirect"));return}if(o.redirect==="follow"){Ir(o,h).then(w=>{i.resolve(w)},w=>{i.reject(w)});return}}this.emitter.listenerCount("response")>0&&(this.logger.info('emitting the "response" event...'),await ie(this.emitter,"response",{response:h.clone(),isMockedResponse:!0,request:o,requestId:s})),i.resolve(h)},onRequestError:l=>{this.logger.info("request has errored!",{response:l}),i.reject(x(l))},onError:l=>{this.logger.info("request has been aborted!",{error:l}),i.reject(l)}})?(this.logger.info("request has been handled, returning mock promise..."),i):(this.logger.info("no mocked response received, performing request as-is..."),e(o).then(async l=>{if(this.logger.info("original fetch performed",l),this.emitter.listenerCount("response")>0){this.logger.info('emitting the "response" event...');const d=l.clone();await ie(this.emitter,"response",{response:d,isMockedResponse:!1,request:o,requestId:s})}return l}))},Object.defineProperty(globalThis.fetch,U,{enumerable:!0,configurable:!0,value:!0}),this.subscriptions.push(()=>{Object.defineProperty(globalThis.fetch,U,{value:void 0}),globalThis.fetch=e,this.logger.info('restored native "globalThis.fetch"!',globalThis.fetch.name)})}},it=ot;it.symbol=Symbol("fetch");function Mr(e,t){const r=new Uint8Array(e.byteLength+t.byteLength);return r.set(e,0),r.set(t,e.byteLength),r}var at=class{constructor(e,t){this.NONE=0,this.CAPTURING_PHASE=1,this.AT_TARGET=2,this.BUBBLING_PHASE=3,this.type="",this.srcElement=null,this.currentTarget=null,this.eventPhase=0,this.isTrusted=!0,this.composed=!1,this.cancelable=!0,this.defaultPrevented=!1,this.bubbles=!0,this.lengthComputable=!0,this.loaded=0,this.total=0,this.cancelBubble=!1,this.returnValue=!0,this.type=e,this.target=(t==null?void 0:t.target)||null,this.currentTarget=(t==null?void 0:t.currentTarget)||null,this.timeStamp=Date.now()}composedPath(){return[]}initEvent(e,t,r){this.type=e,this.bubbles=!!t,this.cancelable=!!r}preventDefault(){this.defaultPrevented=!0}stopPropagation(){}stopImmediatePropagation(){}},_r=class extends at{constructor(e,t){super(e),this.lengthComputable=(t==null?void 0:t.lengthComputable)||!1,this.composed=(t==null?void 0:t.composed)||!1,this.loaded=(t==null?void 0:t.loaded)||0,this.total=(t==null?void 0:t.total)||0}},jr=typeof ProgressEvent<"u";function Ar(e,t,r){const s=["error","progress","loadstart","loadend","load","timeout","abort"],n=jr?ProgressEvent:_r;return s.includes(t)?new n(t,{lengthComputable:!0,loaded:(r==null?void 0:r.loaded)||0,total:(r==null?void 0:r.total)||0}):new at(t,{target:e,currentTarget:e})}function ct(e,t){if(!(t in e))return null;if(Object.prototype.hasOwnProperty.call(e,t))return e;const s=Reflect.getPrototypeOf(e);return s?ct(s,t):null}function ye(e,t){return new Proxy(e,Wr(t))}function Wr(e){const{constructorCall:t,methodCall:r,getProperty:s,setProperty:n}=e,o={};return typeof t<"u"&&(o.construct=function(i,a,c){const l=Reflect.construct.bind(null,i,a,c);return t.call(c,a,l)}),o.set=function(i,a,c){const l=()=>{const d=ct(i,a)||i,h=Reflect.getOwnPropertyDescriptor(d,a);return typeof(h==null?void 0:h.set)<"u"?(h.set.apply(i,[c]),!0):Reflect.defineProperty(d,a,{writable:!0,enumerable:!0,configurable:!0,value:c})};return typeof n<"u"?n.call(i,[a,c],l):l()},o.get=function(i,a,c){const l=()=>i[a],d=typeof s<"u"?s.call(i,[a,c],l):l();return typeof d=="function"?(...h)=>{const w=d.bind(i,...h);return typeof r<"u"?r.call(i,[a,h],w):w()}:d},o}function Dr(e){return["application/xhtml+xml","application/xml","image/svg+xml","text/html","text/xml"].some(r=>e.startsWith(r))}function Ur(e){try{return JSON.parse(e)}catch{return null}}function Hr(e,t){const r=q.isResponseWithBody(e.status)?t:null;return new q(r,{url:e.responseURL,status:e.status,statusText:e.statusText,headers:$r(e.getAllResponseHeaders())})}function $r(e){const t=new Headers,r=e.split(/[\r\n]+/);for(const s of r){if(s.trim()==="")continue;const[n,...o]=s.split(": "),i=o.join(": ");t.append(n,i)}return t}async function Be(e){const t=e.headers.get("content-length");return t!=null&&t!==""?Number(t):(await e.arrayBuffer()).byteLength}var z=Symbol("kIsRequestHandled"),Br=Ce(),ve=Symbol("kFetchRequest"),Nr=class{constructor(e,t){this.initialRequest=e,this.logger=t,this.method="GET",this.url=null,this[z]=!1,this.events=new Map,this.uploadEvents=new Map,this.requestId=tt(),this.requestHeaders=new Headers,this.responseBuffer=new Uint8Array,this.request=ye(e,{setProperty:([r,s],n)=>{switch(r){case"ontimeout":{const o=r.slice(2);return this.request.addEventListener(o,s),n()}default:return n()}},methodCall:([r,s],n)=>{var o;switch(r){case"open":{const[i,a]=s;return typeof a>"u"?(this.method="GET",this.url=Ne(i)):(this.method=i,this.url=Ne(a)),this.logger=this.logger.extend(`${this.method} ${this.url.href}`),this.logger.info("open",this.method,this.url.href),n()}case"addEventListener":{const[i,a]=s;return this.registerEvent(i,a),this.logger.info("addEventListener",i,a),n()}case"setRequestHeader":{const[i,a]=s;return this.requestHeaders.set(i,a),this.logger.info("setRequestHeader",i,a),n()}case"send":{const[i]=s;this.request.addEventListener("load",()=>{if(typeof this.onResponse<"u"){const d=Hr(this.request,this.request.response);this.onResponse.call(this,{response:d,isMockedResponse:this[z],request:c,requestId:this.requestId})}});const a=typeof i=="string"?Qt(i):i,c=this.toFetchApiRequest(a);this[ve]=c.clone(),(((o=this.onRequest)==null?void 0:o.call(this,{request:c,requestId:this.requestId}))||Promise.resolve()).finally(()=>{if(!this[z])return this.logger.info("request callback settled but request has not been handled (readystate %d), performing as-is...",this.request.readyState),Br&&this.request.setRequestHeader(hr,this.requestId),n()});break}default:return n()}}}),j(this.request,"upload",ye(this.request.upload,{setProperty:([r,s],n)=>{switch(r){case"onloadstart":case"onprogress":case"onaboart":case"onerror":case"onload":case"ontimeout":case"onloadend":{const o=r.slice(2);this.registerUploadEvent(o,s)}}return n()},methodCall:([r,s],n)=>{switch(r){case"addEventListener":{const[o,i]=s;return this.registerUploadEvent(o,i),this.logger.info("upload.addEventListener",o,i),n()}}}}))}registerEvent(e,t){const s=(this.events.get(e)||[]).concat(t);this.events.set(e,s),this.logger.info('registered event "%s"',e,t)}registerUploadEvent(e,t){const s=(this.uploadEvents.get(e)||[]).concat(t);this.uploadEvents.set(e,s),this.logger.info('registered upload event "%s"',e,t)}async respondWith(e){if(this[z]=!0,this[ve]){const s=await Be(this[ve]);this.trigger("loadstart",this.request.upload,{loaded:0,total:s}),this.trigger("progress",this.request.upload,{loaded:s,total:s}),this.trigger("load",this.request.upload,{loaded:s,total:s}),this.trigger("loadend",this.request.upload,{loaded:s,total:s})}this.logger.info("responding with a mocked response: %d %s",e.status,e.statusText),j(this.request,"status",e.status),j(this.request,"statusText",e.statusText),j(this.request,"responseURL",this.url.href),this.request.getResponseHeader=new Proxy(this.request.getResponseHeader,{apply:(s,n,o)=>{if(this.logger.info("getResponseHeader",o[0]),this.request.readyState<this.request.HEADERS_RECEIVED)return this.logger.info("headers not received yet, returning null"),null;const i=e.headers.get(o[0]);return this.logger.info('resolved response header "%s" to',o[0],i),i}}),this.request.getAllResponseHeaders=new Proxy(this.request.getAllResponseHeaders,{apply:()=>{if(this.logger.info("getAllResponseHeaders"),this.request.readyState<this.request.HEADERS_RECEIVED)return this.logger.info("headers not received yet, returning empty string"),"";const n=Array.from(e.headers.entries()).map(([o,i])=>`${o}: ${i}`).join(`\r
`);return this.logger.info("resolved all response headers to",n),n}}),Object.defineProperties(this.request,{response:{enumerable:!0,configurable:!1,get:()=>this.response},responseText:{enumerable:!0,configurable:!1,get:()=>this.responseText},responseXML:{enumerable:!0,configurable:!1,get:()=>this.responseXML}});const t=await Be(e.clone());this.logger.info("calculated response body length",t),this.trigger("loadstart",this.request,{loaded:0,total:t}),this.setReadyState(this.request.HEADERS_RECEIVED),this.setReadyState(this.request.LOADING);const r=()=>{this.logger.info("finalizing the mocked response..."),this.setReadyState(this.request.DONE),this.trigger("load",this.request,{loaded:this.responseBuffer.byteLength,total:t}),this.trigger("loadend",this.request,{loaded:this.responseBuffer.byteLength,total:t})};if(e.body){this.logger.info("mocked response has body, streaming...");const s=e.body.getReader(),n=async()=>{const{value:o,done:i}=await s.read();if(i){this.logger.info("response body stream done!"),r();return}o&&(this.logger.info("read response body chunk:",o),this.responseBuffer=Mr(this.responseBuffer,o),this.trigger("progress",this.request,{loaded:this.responseBuffer.byteLength,total:t})),n()};n()}else r()}responseBufferToText(){return Zt(this.responseBuffer)}get response(){if(this.logger.info("getResponse (responseType: %s)",this.request.responseType),this.request.readyState!==this.request.DONE)return null;switch(this.request.responseType){case"json":{const e=Ur(this.responseBufferToText());return this.logger.info("resolved response JSON",e),e}case"arraybuffer":{const e=er(this.responseBuffer);return this.logger.info("resolved response ArrayBuffer",e),e}case"blob":{const e=this.request.getResponseHeader("Content-Type")||"text/plain",t=new Blob([this.responseBufferToText()],{type:e});return this.logger.info("resolved response Blob (mime type: %s)",t,e),t}default:{const e=this.responseBufferToText();return this.logger.info('resolving "%s" response type as text',this.request.responseType,e),e}}}get responseText(){if(P(this.request.responseType===""||this.request.responseType==="text","InvalidStateError: The object is in invalid state."),this.request.readyState!==this.request.LOADING&&this.request.readyState!==this.request.DONE)return"";const e=this.responseBufferToText();return this.logger.info('getResponseText: "%s"',e),e}get responseXML(){if(P(this.request.responseType===""||this.request.responseType==="document","InvalidStateError: The object is in invalid state."),this.request.readyState!==this.request.DONE)return null;const e=this.request.getResponseHeader("Content-Type")||"";return typeof DOMParser>"u"?(console.warn("Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly."),null):Dr(e)?new DOMParser().parseFromString(this.responseBufferToText(),e):null}errorWith(e){this[z]=!0,this.logger.info("responding with an error"),this.setReadyState(this.request.DONE),this.trigger("error",this.request),this.trigger("loadend",this.request)}setReadyState(e){if(this.logger.info("setReadyState: %d -> %d",this.request.readyState,e),this.request.readyState===e){this.logger.info("ready state identical, skipping transition...");return}j(this.request,"readyState",e),this.logger.info("set readyState to: %d",e),e!==this.request.UNSENT&&(this.logger.info('triggerring "readystatechange" event...'),this.trigger("readystatechange",this.request))}trigger(e,t,r){const s=t[`on${e}`],n=Ar(t,e,r);this.logger.info('trigger "%s"',e,r||""),typeof s=="function"&&(this.logger.info('found a direct "%s" callback, calling...',e),s.call(t,n));const o=t instanceof XMLHttpRequestUpload?this.uploadEvents:this.events;for(const[i,a]of o)i===e&&(this.logger.info('found %d listener(s) for "%s" event, calling...',a.length,e),a.forEach(c=>c.call(t,n)))}toFetchApiRequest(e){this.logger.info("converting request to a Fetch API Request...");const t=e instanceof Document?e.documentElement.innerText:e,r=new Request(this.url.href,{method:this.method,headers:this.requestHeaders,credentials:this.request.withCredentials?"include":"same-origin",body:["GET","HEAD"].includes(this.method.toUpperCase())?null:t}),s=ye(r.headers,{methodCall:([n,o],i)=>{switch(n){case"append":case"set":{const[a,c]=o;this.request.setRequestHeader(a,c);break}case"delete":{const[a]=o;console.warn(`XMLHttpRequest: Cannot remove a "${a}" header from the Fetch API representation of the "${r.method} ${r.url}" request. XMLHttpRequest headers cannot be removed.`);break}}return i()}});return j(r,"headers",s),this.logger.info("converted request to a Fetch API Request!",r),r}};function Ne(e){return typeof location>"u"?new URL(e):new URL(e.toString(),location.href)}function j(e,t,r){Reflect.defineProperty(e,t,{writable:!0,enumerable:!0,value:r})}function Fr({emitter:e,logger:t}){return new Proxy(globalThis.XMLHttpRequest,{construct(s,n,o){t.info("constructed new XMLHttpRequest");const i=Reflect.construct(s,n,o),a=Object.getOwnPropertyDescriptors(s.prototype);for(const l in a)Reflect.defineProperty(i,l,a[l]);const c=new Nr(i,t);return c.onRequest=async function({request:l,requestId:d}){const h=new Oe(l);this.logger.info("awaiting mocked response..."),this.logger.info('emitting the "request" event for %s listener(s)...',e.listenerCount("request")),await st({request:l,requestId:d,controller:h,emitter:e,onResponse:async O=>{await this.respondWith(O)},onRequestError:()=>{this.errorWith(new TypeError("Network error"))},onError:O=>{this.logger.info("request errored!",{error:O}),O instanceof Error&&this.errorWith(O)}})||this.logger.info("no mocked response received, performing request as-is...")},c.onResponse=async function({response:l,isMockedResponse:d,request:h,requestId:w}){this.logger.info('emitting the "response" event for %s listener(s)...',e.listenerCount("response")),e.emit("response",{response:l,isMockedResponse:d,request:h,requestId:w})},c.request}})}var lt=class extends Te{constructor(){super(lt.interceptorSymbol)}checkEnvironment(){return nt("XMLHttpRequest")}setup(){const e=this.logger.extend("setup");e.info('patching "XMLHttpRequest" module...');const t=globalThis.XMLHttpRequest;P(!t[U],'Failed to patch the "XMLHttpRequest" module: already patched.'),globalThis.XMLHttpRequest=Fr({emitter:this.emitter,logger:this.logger}),e.info('native "XMLHttpRequest" module patched!',globalThis.XMLHttpRequest.name),Object.defineProperty(globalThis.XMLHttpRequest,U,{enumerable:!0,configurable:!0,value:!0}),this.subscriptions.push(()=>{Object.defineProperty(globalThis.XMLHttpRequest,U,{value:void 0}),globalThis.XMLHttpRequest=t,e.info('native "XMLHttpRequest" module restored!',globalThis.XMLHttpRequest.name)})}},ut=lt;ut.interceptorSymbol=Symbol("xhr");function Gr(e,t){const r=new Se({name:"fallback",interceptors:[new it,new ut]});return r.on("request",async({request:s,requestId:n,controller:o})=>{const i=s.clone(),a=await Xe(s,n,e.getRequestHandlers().filter(qe("RequestHandler")),t,e.emitter,{onMockedResponse(c,{handler:l,parsedResult:d}){t.quiet||e.emitter.once("response:mocked",({response:h})=>{l.log({request:i,response:h,parsedResult:d})})}});a&&o.respondWith(a)}),r.on("response",({response:s,isMockedResponse:n,request:o,requestId:i})=>{e.emitter.emit(n?"response:mocked":"response:bypass",{response:s,request:o,requestId:i})}),r.apply(),r}function Xr(e){return async function(r){e.fallbackInterceptor=Gr(e,r),Ye({message:"Mocking enabled (fallback mode).",quiet:r.quiet})}}function zr(e){return function(){var r,s;(r=e.fallbackInterceptor)==null||r.dispose(),rt({quiet:(s=e.startOptions)==null?void 0:s.quiet})}}function Kr(){try{const e=new ReadableStream({start:r=>r.close()});return new MessageChannel().port1.postMessage(e,[e]),!0}catch{return!1}}var Vr=class extends bt{constructor(...t){super(...t);E(this,"context");E(this,"startHandler",null);E(this,"stopHandler",null);E(this,"listeners");P(!Ce(),p.formatMessage("Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.")),this.listeners=[],this.context=this.createWorkerContext()}createWorkerContext(){const t={isMockingEnabled:!1,startOptions:null,worker:null,getRequestHandlers:()=>this.handlersController.currentHandlers(),registration:null,requests:new Map,emitter:this.emitter,workerChannel:{on:(r,s)=>{this.context.events.addListener(navigator.serviceWorker,"message",n=>{if(n.source!==this.context.worker)return;const o=n.data;o&&o.type===r&&s(n,o)})},send:r=>{var s;(s=this.context.worker)==null||s.postMessage(r)}},events:{addListener:(r,s,n)=>(r.addEventListener(s,n),this.listeners.push({eventType:s,target:r,callback:n}),()=>{r.removeEventListener(s,n)}),removeAllListeners:()=>{for(const{target:r,eventType:s,callback:n}of this.listeners)r.removeEventListener(s,n);this.listeners=[]},once:r=>{const s=[];return new Promise((n,o)=>{const i=a=>{try{const c=a.data;c.type===r&&n(c)}catch(c){o(c)}};s.push(this.context.events.addListener(navigator.serviceWorker,"message",i),this.context.events.addListener(navigator.serviceWorker,"messageerror",o))}).finally(()=>{s.forEach(n=>n())})}},supports:{serviceWorkerApi:!("serviceWorker"in navigator)||location.protocol==="file:",readableStreamTransfer:Kr()}};return this.startHandler=t.supports.serviceWorkerApi?Xr(t):yr(t),this.stopHandler=t.supports.serviceWorkerApi?zr(t):vr(t),t}async start(t={}){return t.waitUntilReady===!0&&p.warn('The "waitUntilReady" option has been deprecated. Please remove it from this "worker.start()" call. Follow the recommended Browser integration (https://mswjs.io/docs/integrations/browser) to eliminate any race conditions between the Service Worker registration and any requests made by your application on initial render.'),this.context.startOptions=ze(br,t),Ct({getUnhandledRequestStrategy:()=>this.context.startOptions.onUnhandledRequest,getHandlers:()=>this.handlersController.currentHandlers(),onMockedConnection:r=>{this.context.startOptions.quiet||Tt(r)},onPassthroughConnection(){}}),be.apply(),this.subscriptions.push(()=>{be.dispose()}),await this.startHandler(this.context.startOptions,t)}stop(){super.dispose(),this.context.events.removeAllListeners(),this.context.emitter.removeAllListeners(),this.stopHandler()}};function Jr(...e){return new Vr(...e)}/*! js-cookie v3.0.5 | MIT */function ee(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var s in r)e[s]=r[s]}return e}var Yr={read:function(e){return e[0]==='"'&&(e=e.slice(1,-1)),e.replace(/(%[\dA-F]{2})+/gi,decodeURIComponent)},write:function(e){return encodeURIComponent(e).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,decodeURIComponent)}};function Re(e,t){function r(n,o,i){if(!(typeof document>"u")){i=ee({},t,i),typeof i.expires=="number"&&(i.expires=new Date(Date.now()+i.expires*864e5)),i.expires&&(i.expires=i.expires.toUTCString()),n=encodeURIComponent(n).replace(/%(2[346B]|5E|60|7C)/g,decodeURIComponent).replace(/[()]/g,escape);var a="";for(var c in i)i[c]&&(a+="; "+c,i[c]!==!0&&(a+="="+i[c].split(";")[0]));return document.cookie=n+"="+e.write(o,n)+a}}function s(n){if(!(typeof document>"u"||arguments.length&&!n)){for(var o=document.cookie?document.cookie.split("; "):[],i={},a=0;a<o.length;a++){var c=o[a].split("="),l=c.slice(1).join("=");try{var d=decodeURIComponent(c[0]);if(i[d]=e.read(l,d),n===d)break}catch{}}return n?i[n]:i}}return Object.create({set:r,get:s,remove:function(n,o){r(n,"",ee({},o,{expires:-1}))},withAttributes:function(n){return Re(this.converter,ee({},this.attributes,n))},withConverter:function(n){return Re(ee({},this.converter,n),this.attributes)}},{attributes:{value:Object.freeze(t)},converter:{value:Object.freeze(e)}})}var re=Re(Yr,{path:"/"}),Qr={VITE_APP_API_URL:"https://api.bulletproofapp.com",VITE_APP_ENABLE_API_MOCKING:"true",BASE_URL:"./",MODE:"production",DEV:!1,PROD:!0,SSR:!1};const Zr=e=>(typeof window>"u"?r=>Buffer.from(r,"binary").toString("base64"):window.btoa)(JSON.stringify(e)),es=e=>{const t=typeof window>"u"?r=>Buffer.from(r,"base64").toString("binary"):window.atob;return JSON.parse(t(e))},dt=e=>{let t=5381,r=e.length;for(;r;)t=t*33^e.charCodeAt(--r);return String(t>>>0)},y=()=>{const e=Qr.TEST?200:Math.floor(Math.random()*700)+300;return Et(e)},ts=(e,t)=>{const r={};for(const s in e)t.includes(s)||(r[s]=e[s]);return r},$=e=>ts(e,["password","iat"]);function Fe({email:e,password:t}){const r=f.user.findFirst({where:{email:{equals:e}}});if((r==null?void 0:r.password)===dt(t)){const n=$(r),o=Zr(n);return{user:n,jwt:o}}throw new Error("Invalid username or password")}const C="shire_app_token";function b(e){try{const t=e[C]||re.get(C);if(!t)return{error:"Unauthorized",user:null};const r=es(t),s=f.user.findFirst({where:{id:{equals:r.id}}});return s?{user:$(s)}:{error:"Unauthorized",user:null}}catch{return{error:"Unauthorized",user:null}}}function se(e){if(e.role!=="ADMIN")throw Error("Unauthorized")}const rs=[g.post(`${m.API_URL}/auth/register`,async({request:e})=>{await y();try{const t=await e.json();if(f.user.findFirst({where:{email:{equals:t.email}}}))return u.json({message:"The user already exists"},{status:400});let s,n;if(t.teamId){if(!f.team.findFirst({where:{id:{equals:t.teamId}}}))return u.json({message:"The team you are trying to join does not exist!"},{status:400});s=t.teamId,n="USER"}else{const i=f.team.create({name:t.teamName??`${t.firstName} Team`});await L("team"),s=i.id,n="ADMIN"}f.user.create({...t,role:n,password:dt(t.password),teamId:s}),await L("user");const o=Fe({email:t.email,password:t.password});return re.set(C,o.jwt,{path:"/"}),u.json(o,{headers:{"Set-Cookie":`${C}=${o.jwt}; Path=/;`}})}catch(t){return u.json({message:(t==null?void 0:t.message)||"Server Error"},{status:500})}}),g.post(`${m.API_URL}/auth/login`,async({request:e})=>{await y();try{const t=await e.json(),r=Fe(t);return re.set(C,r.jwt,{path:"/"}),u.json(r,{headers:{"Set-Cookie":`${C}=${r.jwt}; Path=/;`}})}catch(t){return u.json({message:(t==null?void 0:t.message)||"Server Error"},{status:500})}}),g.post(`${m.API_URL}/auth/logout`,async()=>(await y(),re.remove(C),u.json({message:"Logged out"},{headers:{"Set-Cookie":`${C}=; Path=/;`}}))),g.get(`${m.API_URL}/auth/me`,async({cookies:e})=>{await y();try{const{user:t}=b(e);return u.json({data:t})}catch(t){return u.json({message:(t==null?void 0:t.message)||"Server Error"},{status:500})}})],ss=[g.get(`${m.API_URL}/comments`,async({request:e,cookies:t})=>{await y();try{const{error:r}=b(t);if(r)return u.json({message:r},{status:401});const s=new URL(e.url),n=s.searchParams.get("discussionId")||"",o=Number(s.searchParams.get("page")||1),i=f.comment.count({where:{discussionId:{equals:n}}}),a=Math.ceil(i/10),c=f.comment.findMany({where:{discussionId:{equals:n}},take:10,skip:10*(o-1)}).map(({authorId:l,...d})=>{const h=f.user.findFirst({where:{id:{equals:l}}});return{...d,author:h?$(h):{}}});return u.json({data:c,meta:{page:o,total:i,totalPages:a}})}catch(r){return u.json({message:(r==null?void 0:r.message)||"Server Error"},{status:500})}}),g.post(`${m.API_URL}/comments`,async({request:e,cookies:t})=>{await y();try{const{user:r,error:s}=b(t);if(s)return u.json({message:s},{status:401});const n=await e.json(),o=f.comment.create({authorId:r==null?void 0:r.id,...n});return await L("comment"),u.json(o)}catch(r){return u.json({message:(r==null?void 0:r.message)||"Server Error"},{status:500})}}),g.delete(`${m.API_URL}/comments/:commentId`,async({params:e,cookies:t})=>{await y();try{const{user:r,error:s}=b(t);if(s)return u.json({message:s},{status:401});const n=e.commentId,o=f.comment.delete({where:{id:{equals:n},...(r==null?void 0:r.role)==="USER"&&{authorId:{equals:r.id}}}});return await L("comment"),u.json(o)}catch(r){return u.json({message:(r==null?void 0:r.message)||"Server Error"},{status:500})}})],ns=[g.get(`${m.API_URL}/discussions`,async({cookies:e,request:t})=>{await y();try{const{user:r,error:s}=b(e);if(s)return u.json({message:s},{status:401});const n=new URL(t.url),o=Number(n.searchParams.get("page")||1),i=f.discussion.count({where:{teamId:{equals:r==null?void 0:r.teamId}}}),a=Math.ceil(i/10),c=f.discussion.findMany({where:{teamId:{equals:r==null?void 0:r.teamId}},take:10,skip:10*(o-1)}).map(({authorId:l,...d})=>{const h=f.user.findFirst({where:{id:{equals:l}}});return{...d,author:h?$(h):{}}});return u.json({data:c,meta:{page:o,total:i,totalPages:a}})}catch(r){return u.json({message:(r==null?void 0:r.message)||"Server Error"},{status:500})}}),g.get(`${m.API_URL}/discussions/:discussionId`,async({params:e,cookies:t})=>{await y();try{const{user:r,error:s}=b(t);if(s)return u.json({message:s},{status:401});const n=e.discussionId,o=f.discussion.findFirst({where:{id:{equals:n},teamId:{equals:r==null?void 0:r.teamId}}});if(!o)return u.json({message:"Discussion not found"},{status:404});const i=f.user.findFirst({where:{id:{equals:o.authorId}}}),a={...o,author:i?$(i):{}};return u.json({data:a})}catch(r){return u.json({message:(r==null?void 0:r.message)||"Server Error"},{status:500})}}),g.post(`${m.API_URL}/discussions`,async({request:e,cookies:t})=>{await y();try{const{user:r,error:s}=b(t);if(s)return u.json({message:s},{status:401});const n=await e.json();se(r);const o=f.discussion.create({teamId:r==null?void 0:r.teamId,authorId:r==null?void 0:r.id,...n});return await L("discussion"),u.json(o)}catch(r){return u.json({message:(r==null?void 0:r.message)||"Server Error"},{status:500})}}),g.patch(`${m.API_URL}/discussions/:discussionId`,async({request:e,params:t,cookies:r})=>{await y();try{const{user:s,error:n}=b(r);if(n)return u.json({message:n},{status:401});const o=await e.json(),i=t.discussionId;se(s);const a=f.discussion.update({where:{teamId:{equals:s==null?void 0:s.teamId},id:{equals:i}},data:o});return await L("discussion"),u.json(a)}catch(s){return u.json({message:(s==null?void 0:s.message)||"Server Error"},{status:500})}}),g.delete(`${m.API_URL}/discussions/:discussionId`,async({cookies:e,params:t})=>{await y();try{const{user:r,error:s}=b(e);if(s)return u.json({message:s},{status:401});const n=t.discussionId;se(r);const o=f.discussion.delete({where:{id:{equals:n}}});return await L("discussion"),u.json(o)}catch(r){return u.json({message:(r==null?void 0:r.message)||"Server Error"},{status:500})}})],os=[g.get(`${m.API_URL}/teams`,async()=>{await y();try{const e=f.team.getAll();return u.json({data:e})}catch(e){return u.json({message:(e==null?void 0:e.message)||"Server Error"},{status:500})}})],is=[g.get(`${m.API_URL}/users`,async({cookies:e})=>{await y();try{const{user:t,error:r}=b(e);if(r)return u.json({message:r},{status:401});const s=f.user.findMany({where:{teamId:{equals:t==null?void 0:t.teamId}}}).map($);return u.json({data:s})}catch(t){return u.json({message:(t==null?void 0:t.message)||"Server Error"},{status:500})}}),g.patch(`${m.API_URL}/users/profile`,async({request:e,cookies:t})=>{await y();try{const{user:r,error:s}=b(t);if(s)return u.json({message:s},{status:401});const n=await e.json(),o=f.user.update({where:{id:{equals:r==null?void 0:r.id}},data:n});return await L("user"),u.json(o)}catch(r){return u.json({message:(r==null?void 0:r.message)||"Server Error"},{status:500})}}),g.delete(`${m.API_URL}/users/:userId`,async({cookies:e,params:t})=>{await y();try{const{user:r,error:s}=b(e);if(s)return u.json({message:s},{status:401});const n=t.userId;se(r);const o=f.user.delete({where:{id:{equals:n},teamId:{equals:r==null?void 0:r.teamId}}});return await L("user"),u.json(o)}catch(r){return u.json({message:(r==null?void 0:r.message)||"Server Error"},{status:500})}})],as=[...rs,...ss,...ns,...os,...is,g.get(`${m.API_URL}/healthcheck`,async()=>(await y(),u.json({ok:!0})))],ds=Jr(...as);export{ds as worker};
